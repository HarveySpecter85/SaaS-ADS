---
phase: 10-polish-integration
plan: 01
type: execute
depends_on: []
files_modified: [src/components/loading.tsx, src/components/error-boundary.tsx, src/app/(dashboard)/brands/loading.tsx, src/app/(dashboard)/products/loading.tsx, src/app/(dashboard)/campaigns/loading.tsx, src/app/(dashboard)/gallery/loading.tsx]
---

<objective>
Add loading states and error handling across the application.

Purpose: Improve user experience with visual feedback during data fetching and graceful error recovery.
Output: Loading skeleton components, error boundary, loading.tsx files for each route.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**From ROADMAP.md - Phase 10 Goal:**
- Final integration testing, performance optimization, production deployment
- Polish the user experience

**Existing patterns:**
- Tailwind CSS v4 with slate/gray palette
- Server Components with async data fetching
- Client Components for interactivity

**Key files:**
@src/components/sidebar.tsx
@src/app/(dashboard)/page.tsx
@src/app/(dashboard)/brands/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reusable loading skeleton components</name>
  <files>src/components/loading.tsx</files>
  <action>
Create loading skeleton components for common UI patterns:

```typescript
// Skeleton base with pulse animation
export function Skeleton({ className }: { className?: string })

// Card skeleton for list items
export function CardSkeleton()

// Table row skeleton
export function TableRowSkeleton()

// Page header skeleton
export function PageHeaderSkeleton()

// Stats card skeleton (for dashboard)
export function StatsCardSkeleton()
```

Use Tailwind's `animate-pulse` class with `bg-slate-200` for skeleton elements. Match the existing card styling patterns (rounded-lg, border, etc.).
  </action>
  <verify>npm run build succeeds, components export correctly</verify>
  <done>Loading skeleton components created with consistent styling</done>
</task>

<task type="auto">
  <name>Task 2: Create error boundary component</name>
  <files>src/components/error-boundary.tsx</files>
  <action>
Create a client-side error boundary component:

```typescript
'use client';

interface ErrorBoundaryProps {
  error: Error & { digest?: string };
  reset: () => void;
}

export function ErrorBoundary({ error, reset }: ErrorBoundaryProps)
```

Display:
- Error icon (red exclamation)
- "Something went wrong" heading
- Error message (if available, truncated)
- "Try again" button that calls reset()
- Link to go back to dashboard

Style with existing slate palette. Keep it simple and professional.
  </action>
  <verify>npm run build succeeds, component renders correctly</verify>
  <done>Error boundary component ready for use in error.tsx files</done>
</task>

<task type="auto">
  <name>Task 3: Add loading.tsx files to main routes</name>
  <files>src/app/(dashboard)/brands/loading.tsx, src/app/(dashboard)/products/loading.tsx, src/app/(dashboard)/campaigns/loading.tsx, src/app/(dashboard)/gallery/loading.tsx</files>
  <action>
Create loading.tsx files for each main route using the skeleton components:

**brands/loading.tsx:**
- Page header skeleton
- Grid of 6 card skeletons (matching brand card layout)

**products/loading.tsx:**
- Page header skeleton
- Grid of 6 card skeletons (matching product card layout)

**campaigns/loading.tsx:**
- Page header skeleton
- List of 5 table row skeletons

**gallery/loading.tsx:**
- Page header skeleton
- Filter bar skeleton
- Grid of 12 small image skeletons

Import from `@/components/loading` and compose appropriate layouts.
  </action>
  <verify>npm run build succeeds, navigate to routes and see loading states briefly</verify>
  <done>Loading states display during route transitions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] Loading skeleton components render correctly
- [ ] Error boundary component compiles without errors
- [ ] Loading.tsx files work for route transitions
- [ ] No TypeScript or ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Loading states provide visual feedback
- Error handling is graceful and user-friendly
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish-integration/10-01-SUMMARY.md`

Commit guidance:
- Task 1: `feat(10-01): create loading skeleton components`
- Task 2: `feat(10-01): create error boundary component`
- Task 3: `feat(10-01): add loading states to main routes`
- Metadata: `docs(10-01): complete loading and error handling plan`
</output>
