---
phase: 10-polish-integration
plan: 02
type: execute
depends_on: []
files_modified: [vercel.json, src/lib/env.ts, src/app/(dashboard)/loading.tsx, src/app/(dashboard)/error.tsx]
---

<objective>
Configure deployment and add final polish for production readiness.

Purpose: Ensure smooth Vercel deployment with proper environment handling and global error/loading states.
Output: Vercel configuration, environment validation, global error and loading handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**From ROADMAP.md - Phase 10 Goal:**
- Final integration testing, performance optimization, production deployment

**Environment variables needed (from .env.local.example pattern):**
- NEXT_PUBLIC_SUPABASE_URL
- NEXT_PUBLIC_SUPABASE_ANON_KEY
- GOOGLE_AI_API_KEY
- OPENWEATHERMAP_API_KEY

**Deployment target:** Vercel (from PROJECT.md constraints)

**Key files:**
@src/lib/supabase/server.ts
@src/lib/gemini.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Vercel configuration</name>
  <files>vercel.json</files>
  <action>
Create vercel.json with production-ready settings:

```json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "framework": "nextjs",
  "regions": ["iad1"],
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        { "key": "Cache-Control", "value": "no-store, max-age=0" }
      ]
    }
  ]
}
```

- Use `iad1` (US East) as default region for API latency
- Disable caching on API routes to ensure fresh data
- Keep configuration minimal - Next.js handles most settings automatically
  </action>
  <verify>vercel.json is valid JSON, no syntax errors</verify>
  <done>Vercel configuration ready for deployment</done>
</task>

<task type="auto">
  <name>Task 2: Create environment validation utility</name>
  <files>src/lib/env.ts</files>
  <action>
Create environment variable validation for runtime safety:

```typescript
// Required environment variables
const requiredEnvVars = [
  'NEXT_PUBLIC_SUPABASE_URL',
  'NEXT_PUBLIC_SUPABASE_ANON_KEY',
] as const;

// Optional but recommended
const optionalEnvVars = [
  'GOOGLE_AI_API_KEY',
  'OPENWEATHERMAP_API_KEY',
] as const;

export function validateEnv() {
  const missing: string[] = [];

  for (const envVar of requiredEnvVars) {
    if (!process.env[envVar]) {
      missing.push(envVar);
    }
  }

  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
}

// Type-safe env access
export const env = {
  supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL!,
  supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  googleAiApiKey: process.env.GOOGLE_AI_API_KEY,
  openWeatherMapApiKey: process.env.OPENWEATHERMAP_API_KEY,
} as const;
```

This provides runtime validation and type-safe access to environment variables.
  </action>
  <verify>npm run build succeeds, env.ts exports correctly</verify>
  <done>Environment validation utility ready</done>
</task>

<task type="auto">
  <name>Task 3: Add global dashboard loading and error handlers</name>
  <files>src/app/(dashboard)/loading.tsx, src/app/(dashboard)/error.tsx</files>
  <action>
Create global loading and error handlers for the dashboard route group:

**loading.tsx:**
```typescript
import { PageHeaderSkeleton, StatsCardSkeleton } from '@/components/loading';

export default function DashboardLoading() {
  return (
    <div className="space-y-6">
      <PageHeaderSkeleton />
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {Array.from({ length: 4 }).map((_, i) => (
          <StatsCardSkeleton key={i} />
        ))}
      </div>
    </div>
  );
}
```

**error.tsx:**
```typescript
'use client';

import { ErrorBoundary } from '@/components/error-boundary';

export default function DashboardError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return <ErrorBoundary error={error} reset={reset} />;
}
```

These provide fallbacks for any unhandled loading/error states in the dashboard.
  </action>
  <verify>npm run build succeeds, loading and error pages render</verify>
  <done>Global dashboard loading and error handlers in place</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] vercel.json is valid
- [ ] Environment validation works
- [ ] Global loading/error handlers render
- [ ] No TypeScript or ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Application ready for Vercel deployment
- Phase 10 complete
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish-integration/10-02-SUMMARY.md`

Commit guidance:
- Task 1: `feat(10-02): create Vercel configuration`
- Task 2: `feat(10-02): create environment validation utility`
- Task 3: `feat(10-02): add global dashboard loading and error handlers`
- Metadata: `docs(10-02): complete deployment configuration plan`
</output>
