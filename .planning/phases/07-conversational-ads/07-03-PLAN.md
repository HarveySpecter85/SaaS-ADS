---
phase: 07-conversational-ads
plan: 03
type: execute
depends_on: ["07-02"]
files_modified: [src/lib/chat.ts, src/lib/product-matcher.ts, src/app/api/chat/route.ts, src/components/chat-widget.tsx, src/components/product-recommendation.tsx]
---

<objective>
Add smart product recommendations to the chat based on conversation context.

Purpose: Enable the chat to suggest specific products with images based on what visitors describe.
Output: Product matching logic, recommendation display component, enhanced chat context.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-conversational-ads/07-CONTEXT.md
@.planning/phases/07-conversational-ads/07-02-SUMMARY.md

**From CONTEXT.md - Essential:**
- Smart recommendations â€” The chat asks the right questions and suggests relevant products
- The AI should feel helpful and knowledgeable, guiding visitors to the right products

**Product data available (Phase 3):**
- Products with name, description, SKU
- Product images with hero image flagged
- Brand association for filtering

**Strategy:**
- Gemini extracts intent and product criteria from conversation
- Product matcher finds relevant products from catalog
- Display product cards inline in chat with images
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product matcher and recommendation types</name>
  <files>src/lib/product-matcher.ts</files>
  <action>
Create src/lib/product-matcher.ts:

```typescript
import { createClient } from '@/lib/supabase/server';

// Product with image for display
export interface ProductRecommendation {
  id: string;
  name: string;
  description: string | null;
  imageUrl: string | null;
  sku: string | null;
}

// Criteria extracted from conversation
export interface ProductCriteria {
  keywords: string[];       // Keywords to match in name/description
  category?: string;        // Category if mentioned
  priceRange?: {
    min?: number;
    max?: number;
  };
}

// Extract criteria from conversation using Gemini
export async function extractProductCriteria(
  conversation: string
): Promise<ProductCriteria> {
  const { GoogleGenerativeAI } = await import('@google/generative-ai');
  const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!);
  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

  const prompt = `Analyze this conversation and extract product search criteria.

Conversation:
${conversation}

Return JSON with:
- keywords: array of relevant product keywords/features mentioned
- category: product category if mentioned (optional)

Only include criteria that are clearly stated. Be specific.
Return valid JSON only, no markdown.`;

  const result = await model.generateContent(prompt);
  const text = result.response.text();

  try {
    // Clean potential markdown code blocks
    const cleaned = text.replace(/```json\n?|\n?```/g, '').trim();
    return JSON.parse(cleaned);
  } catch {
    return { keywords: [] };
  }
}

// Find matching products based on criteria
export async function findMatchingProducts(
  brandId: string,
  criteria: ProductCriteria,
  limit: number = 3
): Promise<ProductRecommendation[]> {
  const supabase = await createClient();

  // Start with products for this brand
  let query = supabase
    .from('products')
    .select(`
      id,
      name,
      description,
      sku,
      images:product_images(image_url, is_hero)
    `)
    .eq('brand_id', brandId);

  // Get all products for this brand (we'll filter in memory for keyword matching)
  const { data: products, error } = await query;

  if (error || !products?.length) {
    return [];
  }

  // Score products by keyword matches
  const scored = products.map(product => {
    let score = 0;
    const searchText = `${product.name} ${product.description || ''}`.toLowerCase();

    for (const keyword of criteria.keywords) {
      if (searchText.includes(keyword.toLowerCase())) {
        score += 1;
      }
    }

    return { product, score };
  });

  // Sort by score and take top matches
  const matches = scored
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit)
    .map(s => {
      const heroImage = s.product.images?.find((img: { is_hero: boolean }) => img.is_hero);
      const firstImage = s.product.images?.[0];

      return {
        id: s.product.id,
        name: s.product.name,
        description: s.product.description,
        sku: s.product.sku,
        imageUrl: heroImage?.image_url || firstImage?.image_url || null,
      };
    });

  return matches;
}
```

**Key points:**
- Uses Gemini to extract search criteria from natural conversation
- Scores products by keyword matches in name/description
- Returns products with hero images for display
- Handles graceful fallbacks
  </action>
  <verify>npm run build succeeds, types compile correctly</verify>
  <done>Product matching logic ready for chat integration</done>
</task>

<task type="auto">
  <name>Task 2: Create product recommendation component</name>
  <files>src/components/product-recommendation.tsx</files>
  <action>
Create src/components/product-recommendation.tsx:

```typescript
'use client';

import Image from 'next/image';
import Link from 'next/link';

interface ProductRecommendationProps {
  id: string;
  name: string;
  description: string | null;
  imageUrl: string | null;
}

export function ProductRecommendation({
  id,
  name,
  description,
  imageUrl,
}: ProductRecommendationProps) {
  return (
    <Link
      href={`/products/${id}`}
      className="block bg-white border border-gray-200 rounded-lg overflow-hidden hover:shadow-md transition-shadow"
    >
      {/* Product image */}
      <div className="aspect-square relative bg-gray-100">
        {imageUrl ? (
          <Image
            src={imageUrl}
            alt={name}
            fill
            className="object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-gray-400">
            No image
          </div>
        )}
      </div>

      {/* Product info */}
      <div className="p-3">
        <h4 className="font-medium text-gray-900 text-sm truncate">
          {name}
        </h4>
        {description && (
          <p className="text-xs text-gray-500 mt-1 line-clamp-2">
            {description}
          </p>
        )}
      </div>
    </Link>
  );
}

// Grid of recommendations
interface ProductRecommendationsProps {
  products: ProductRecommendationProps[];
}

export function ProductRecommendations({ products }: ProductRecommendationsProps) {
  if (!products.length) return null;

  return (
    <div className="mt-2">
      <p className="text-xs text-gray-500 mb-2">Recommended for you:</p>
      <div className="grid grid-cols-2 gap-2">
        {products.map(product => (
          <ProductRecommendation key={product.id} {...product} />
        ))}
      </div>
    </div>
  );
}
```

**Implementation:**
- Compact card design that fits in chat panel width
- Image with aspect-square for consistency
- Links to product detail page
- Grid layout for multiple recommendations
- Hover state with shadow
  </action>
  <verify>npm run build succeeds, component renders correctly</verify>
  <done>Product recommendation cards display in chat</done>
</task>

<task type="auto">
  <name>Task 3: Integrate recommendations into chat flow</name>
  <files>src/lib/chat.ts, src/app/api/chat/route.ts, src/components/chat-widget.tsx</files>
  <action>
1. Update src/lib/chat.ts - Add product context to system prompt:

```typescript
// Enhanced context with full product details
export interface ChatContext {
  brandName?: string;
  brandTone?: string[];
  products?: Array<{
    id: string;
    name: string;
    description: string | null;
  }>;
}

// Update buildChatSystemPrompt to include product details
// Add instruction: When user describes what they want, recommend specific products by name
```

2. Update src/app/api/chat/route.ts:

```typescript
// Add endpoint or logic to detect recommendation trigger
// After streaming completes, check if response mentions products
// If so, extract criteria and find matching products
// Return recommendations in response metadata

// New response format (keep streaming for text, add metadata):
// Option A: Add special delimiter at end of stream with JSON
// Option B: Separate /api/chat/recommendations endpoint
// Option C: Two-phase response (stream text, then JSON)

// Use Option A for simplicity:
// Stream ends with: \n---RECOMMENDATIONS---\n{json}
```

3. Update src/components/chat-widget.tsx:

```typescript
// Parse streaming response for recommendations delimiter
// When found, extract JSON and update message with products
// Render ProductRecommendations below assistant message

// Update Message type:
interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  recommendations?: ProductRecommendation[];
}

// In streaming handler, detect delimiter and parse:
if (fullContent.includes('---RECOMMENDATIONS---')) {
  const [text, json] = fullContent.split('---RECOMMENDATIONS---');
  // Update message content to text only
  // Parse json for recommendations
}
```
  </action>
  <verify>npm run build succeeds, chat shows product recommendations based on conversation</verify>
  <done>Smart recommendations appear when relevant in conversation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] Product matcher extracts criteria from conversation
- [ ] Matching products are found based on keywords
- [ ] ProductRecommendation component renders with image
- [ ] Chat displays inline product cards
- [ ] Clicking recommendation goes to product page
- [ ] No TypeScript or ESLint errors
- [ ] Phase 7 complete
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Chat extracts product needs from conversation
- Relevant products displayed with images
- Recommendations feel natural in chat flow
- Phase 7 complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-conversational-ads/07-03-SUMMARY.md`

Commit guidance:
- Task 1: `feat(07-03): create product matcher with criteria extraction`
- Task 2: `feat(07-03): create product recommendation component`
- Task 3: `feat(07-03): integrate recommendations into chat flow`
- Metadata: `docs(07-03): complete product recommendations plan`

Note: This is the final plan for Phase 7. After SUMMARY.md, update ROADMAP.md and STATE.md to mark Phase 7 complete.
</output>
