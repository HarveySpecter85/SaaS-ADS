---
phase: 03-asset-anchoring
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/002_products.sql, src/lib/supabase/database.types.ts, src/app/api/products/route.ts, src/app/api/products/[id]/route.ts, src/app/api/products/[id]/images/route.ts]
---

<objective>
Create database schema and API endpoints for product assets management.

Purpose: Establish the data foundation for storing product images that anchor AI-generated creatives.
Output: Supabase tables for products/images, and CRUD API endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-asset-anchoring/03-CONTEXT.md
@.planning/phases/02-brand-ingestion/02-01-SUMMARY.md

**From CONTEXT.md - Vision:**
- Reference image library with hero image + variants per product
- Each brand has its own asset bank
- One hero image (THE reference) with optional supporting angles

**Tech available (from Phase 2):**
- Supabase client utilities in src/lib/supabase/
- API route patterns established
- TypeScript types pattern (database.types.ts)
- Supabase Storage for file uploads

**Patterns established:**
- Supabase API route pattern with createClient from server.ts
- BrandWithRelations composite type for joined queries
- Replace-all strategy for nested relations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database schema for products and images</name>
  <files>supabase/migrations/002_products.sql, src/lib/supabase/database.types.ts</files>
  <action>
1. Create supabase/migrations/002_products.sql:

```sql
-- Products table (linked to brand)
create table products (
  id uuid primary key default gen_random_uuid(),
  brand_id uuid references brands(id) on delete cascade,
  name text not null,
  description text,
  sku text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Product images table (multiple per product, one hero)
create table product_images (
  id uuid primary key default gen_random_uuid(),
  product_id uuid references products(id) on delete cascade,
  image_url text not null,
  is_hero boolean default false,
  angle text,
  sort_order integer default 0,
  created_at timestamptz default now()
);

-- Enable RLS
alter table products enable row level security;
alter table product_images enable row level security;

-- Policies: allow all operations for authenticated users (internal tool)
create policy "Authenticated users can CRUD products" on products
  for all using (auth.role() = 'authenticated');
create policy "Authenticated users can CRUD product_images" on product_images
  for all using (auth.role() = 'authenticated');

-- Index for faster lookups
create index idx_products_brand_id on products(brand_id);
create index idx_product_images_product_id on product_images(product_id);
```

2. Update src/lib/supabase/database.types.ts - ADD to existing types:

```typescript
export interface Product {
  id: string;
  brand_id: string;
  name: string;
  description: string | null;
  sku: string | null;
  created_at: string;
  updated_at: string;
}

export interface ProductImage {
  id: string;
  product_id: string;
  image_url: string;
  is_hero: boolean;
  angle: string | null;
  sort_order: number;
  created_at: string;
}

export interface ProductWithImages extends Product {
  images: ProductImage[];
}
```

Keep existing Brand types. Add Product types alongside them.
  </action>
  <verify>npm run build succeeds, types file compiles without errors</verify>
  <done>Migration SQL documented, TypeScript types defined for Product and ProductImage</done>
</task>

<task type="auto">
  <name>Task 2: Create product CRUD API endpoints</name>
  <files>src/app/api/products/route.ts, src/app/api/products/[id]/route.ts</files>
  <action>
1. Create src/app/api/products/route.ts (list and create):

```typescript
// GET: List all products (optionally filter by brand_id query param)
// POST: Create new product (name, brand_id, description?, sku?)
```

- GET returns products with their images (use Supabase joins)
- Support optional `?brand_id=uuid` query param to filter by brand
- POST creates product and returns the created record
- Use createClient from '@/lib/supabase/server'
- Return proper HTTP status codes (200, 201, 400, 500)

2. Create src/app/api/products/[id]/route.ts (get, update, delete):

```typescript
// GET: Get single product with all images
// PATCH: Update product metadata (name, description, sku)
// DELETE: Delete product (cascades to images)
```

- GET returns full product with images array, sorted by sort_order
- PATCH accepts partial updates to product fields only (not images)
- DELETE removes product and all images (cascade)
- Validate UUID format for id parameter
- Return 404 for non-existent products

Follow the pattern from /api/brands/[id]/route.ts. Simple, minimal validation (internal tool).
  </action>
  <verify>npm run build succeeds, no TypeScript errors in API routes</verify>
  <done>Product API endpoints created: GET /api/products, POST /api/products, GET/PATCH/DELETE /api/products/[id]</done>
</task>

<task type="auto">
  <name>Task 3: Create product image upload endpoint</name>
  <files>src/app/api/products/[id]/images/route.ts</files>
  <action>
Create src/app/api/products/[id]/images/route.ts:

```typescript
// POST: Upload new image for product
// DELETE: Remove specific image (via query param ?image_id=uuid)
```

POST implementation:
1. Accept multipart/form-data with image file
2. Validate product exists
3. Validate file is image (check content-type: image/*)
4. Upload to Supabase Storage (product-images bucket)
5. Create product_images record with:
   - image_url from storage
   - is_hero = false (first image is hero by default if no hero exists)
   - auto-determine is_hero: if no existing hero, make this one hero
6. Return created image record

DELETE implementation:
1. Accept image_id as query param
2. Remove from storage
3. Delete product_images record
4. If deleted image was hero, promote next image to hero (by sort_order)

Storage path: `products/{product_id}/{uuid}-{filename}`

Error handling:
- 400 if no file or product_id invalid
- 400 if not an image file
- 404 if product not found
- 500 if storage or database fails
  </action>
  <verify>npm run build succeeds, no TypeScript errors</verify>
  <done>POST /api/products/[id]/images uploads images, DELETE removes them, hero promotion works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] TypeScript types compile without errors
- [ ] API route files have correct exports (GET, POST, PATCH, DELETE)
- [ ] No ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Database types defined and importable
- Product CRUD API endpoints exist
- Image upload endpoint handles storage
- Ready for Product UI (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/03-asset-anchoring/03-01-SUMMARY.md`

Commit guidance:
- Task 1: `feat(03-01): add product database types and migration`
- Task 2: `feat(03-01): create product CRUD API endpoints`
- Task 3: `feat(03-01): create product image upload endpoint`
- Metadata: `docs(03-01): complete asset data foundation plan`
</output>
