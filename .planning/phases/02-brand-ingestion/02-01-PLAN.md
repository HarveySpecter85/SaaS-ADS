---
phase: 02-brand-ingestion
plan: 01
type: execute
depends_on: []
files_modified: [src/lib/supabase/database.types.ts, src/app/api/brands/route.ts, src/app/api/brands/[id]/route.ts]
---

<objective>
Create database schema and API endpoints for brand management.

Purpose: Establish the data foundation for storing brand information extracted from PDFs.
Output: Supabase tables for brands/colors/fonts/tone, and CRUD API endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-brand-ingestion/02-CONTEXT.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

**From CONTEXT.md - Vision:**
- Each client/brand gets its own profile page
- Visual-first: colors, fonts, tone
- Easy editing is essential

**Tech available (from Phase 1):**
- Supabase client utilities in src/lib/supabase/
- Next.js App Router patterns established
- Auth middleware protecting routes

**Patterns established:**
- Server Components with async data
- Route groups for dashboard
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase database schema for brands</name>
  <files>supabase/migrations/001_brands.sql, src/lib/supabase/database.types.ts</files>
  <action>
Create SQL migration file and TypeScript types for brand data:

1. Create supabase/migrations/001_brands.sql:

```sql
-- Brands table (one per client)
create table brands (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  description text,
  source_pdf_url text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Brand colors (multiple per brand)
create table brand_colors (
  id uuid primary key default gen_random_uuid(),
  brand_id uuid references brands(id) on delete cascade,
  hex_code text not null,
  name text,
  usage text,
  is_primary boolean default false,
  created_at timestamptz default now()
);

-- Brand fonts (multiple per brand)
create table brand_fonts (
  id uuid primary key default gen_random_uuid(),
  brand_id uuid references brands(id) on delete cascade,
  font_family text not null,
  font_weight text,
  usage text,
  is_primary boolean default false,
  created_at timestamptz default now()
);

-- Brand tone of voice (one per brand, but flexible structure)
create table brand_tone (
  id uuid primary key default gen_random_uuid(),
  brand_id uuid references brands(id) on delete cascade,
  descriptor text not null,
  example text,
  created_at timestamptz default now()
);

-- Enable RLS (but allow all authenticated users - internal tool)
alter table brands enable row level security;
alter table brand_colors enable row level security;
alter table brand_fonts enable row level security;
alter table brand_tone enable row level security;

-- Policies: allow all operations for authenticated users
create policy "Authenticated users can CRUD brands" on brands
  for all using (auth.role() = 'authenticated');
create policy "Authenticated users can CRUD brand_colors" on brand_colors
  for all using (auth.role() = 'authenticated');
create policy "Authenticated users can CRUD brand_fonts" on brand_fonts
  for all using (auth.role() = 'authenticated');
create policy "Authenticated users can CRUD brand_tone" on brand_tone
  for all using (auth.role() = 'authenticated');
```

2. Create src/lib/supabase/database.types.ts with TypeScript interfaces:

```typescript
export interface Brand {
  id: string;
  name: string;
  description: string | null;
  source_pdf_url: string | null;
  created_at: string;
  updated_at: string;
}

export interface BrandColor {
  id: string;
  brand_id: string;
  hex_code: string;
  name: string | null;
  usage: string | null;
  is_primary: boolean;
  created_at: string;
}

export interface BrandFont {
  id: string;
  brand_id: string;
  font_family: string;
  font_weight: string | null;
  usage: string | null;
  is_primary: boolean;
  created_at: string;
}

export interface BrandTone {
  id: string;
  brand_id: string;
  descriptor: string;
  example: string | null;
  created_at: string;
}

export interface BrandWithRelations extends Brand {
  colors: BrandColor[];
  fonts: BrandFont[];
  tone: BrandTone[];
}
```

Note: Migration is for reference - actual Supabase schema changes happen in dashboard or via CLI. The types file is what matters for TypeScript.
  </action>
  <verify>TypeScript compiles: npm run build (types file should have no errors)</verify>
  <done>Migration SQL documented, TypeScript types defined and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create brand CRUD API endpoints</name>
  <files>src/app/api/brands/route.ts, src/app/api/brands/[id]/route.ts</files>
  <action>
Create Next.js API routes for brand management:

1. Create src/app/api/brands/route.ts (list and create):

```typescript
// GET: List all brands
// POST: Create new brand (name, description)
```

- GET returns all brands with their colors, fonts, and tone (use Supabase joins)
- POST creates a new brand and returns the created record
- Use createClient from '@/lib/supabase/server'
- Return proper HTTP status codes (200, 201, 400, 500)
- Include error handling with meaningful messages

2. Create src/app/api/brands/[id]/route.ts (get, update, delete):

```typescript
// GET: Get single brand with all relations
// PATCH: Update brand and/or nested relations
// DELETE: Delete brand (cascades to colors/fonts/tone)
```

- GET returns full brand with colors, fonts, tone arrays
- PATCH accepts partial updates to brand and nested data
- DELETE removes brand and all related data (cascade)
- Validate UUID format for id parameter
- Return 404 for non-existent brands

Keep it simple - no complex validation. This is internal tool, trust the input.
  </action>
  <verify>npm run build succeeds, no TypeScript errors in API routes</verify>
  <done>Brand API endpoints created: GET /api/brands, POST /api/brands, GET/PATCH/DELETE /api/brands/[id]</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] TypeScript types compile without errors
- [ ] API route files have correct exports (GET, POST, PATCH, DELETE)
- [ ] No ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Database types defined and importable
- Brand CRUD API endpoints exist
- Ready for PDF extraction logic (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/02-brand-ingestion/02-01-SUMMARY.md`

Commit guidance:
- Task 1: `feat(02-01): add brand database types and migration`
- Task 2: `feat(02-01): create brand CRUD API endpoints`
- Metadata: `docs(02-01): complete brand data foundation plan`
</output>
