---
phase: 04-prompt-generation
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/003_prompts.sql, src/lib/supabase/database.types.ts, src/app/api/campaigns/route.ts, src/app/api/campaigns/[id]/route.ts, src/app/api/campaigns/[id]/prompts/route.ts]
---

<objective>
Create database schema and API endpoints for campaign templates and prompt management.

Purpose: Establish the data foundation for goal-based campaign templates and generated prompts.
Output: Supabase tables for campaigns/prompts, CRUD API endpoints, and generation endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prompt-generation/04-CONTEXT.md
@.planning/phases/03-asset-anchoring/03-01-SUMMARY.md

**From CONTEXT.md - Vision:**
- Goal-based campaign templates (awareness, lead gen, conversion)
- 50+ prompt variations per batch
- Preview before full generation

**Tech stack available:**
- Supabase (database, storage, RLS)
- Gemini 1.5 Flash (already integrated for PDF extraction)
- Next.js API routes with established patterns

**Established patterns:**
- Supabase API route pattern with createClient from server.ts
- TypeScript types in database.types.ts
- UUID validation helper
- Replace-all strategy for nested relations

**Constraining decisions:**
- Gemini Flash for AI tasks (already proven in Phase 2)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database schema for campaigns and prompts</name>
  <files>supabase/migrations/003_prompts.sql, src/lib/supabase/database.types.ts</files>
  <action>
1. Create supabase/migrations/003_prompts.sql:

```sql
-- Campaign templates (goal-based bundles)
create table campaigns (
  id uuid primary key default gen_random_uuid(),
  product_id uuid references products(id) on delete cascade,
  name text not null,
  goal text not null check (goal in ('awareness', 'lead_gen', 'conversion')),
  status text not null default 'draft' check (status in ('draft', 'generating', 'complete')),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Generated prompts (the actual variations)
create table prompts (
  id uuid primary key default gen_random_uuid(),
  campaign_id uuid references campaigns(id) on delete cascade,
  prompt_text text not null,
  headline text,
  description text,
  cta text,
  variation_type text, -- e.g., 'hero_focus', 'lifestyle', 'benefit_driven'
  is_preview boolean default false,
  created_at timestamptz default now()
);

-- Enable RLS
alter table campaigns enable row level security;
alter table prompts enable row level security;

-- Policies for authenticated users
create policy "Authenticated users can CRUD campaigns" on campaigns
  for all using (auth.role() = 'authenticated');
create policy "Authenticated users can CRUD prompts" on prompts
  for all using (auth.role() = 'authenticated');

-- Indexes
create index idx_campaigns_product_id on campaigns(product_id);
create index idx_prompts_campaign_id on prompts(campaign_id);
```

2. Update src/lib/supabase/database.types.ts - ADD to existing types:

```typescript
export type CampaignGoal = 'awareness' | 'lead_gen' | 'conversion';
export type CampaignStatus = 'draft' | 'generating' | 'complete';

export interface Campaign {
  id: string;
  product_id: string;
  name: string;
  goal: CampaignGoal;
  status: CampaignStatus;
  created_at: string;
  updated_at: string;
}

export interface Prompt {
  id: string;
  campaign_id: string;
  prompt_text: string;
  headline: string | null;
  description: string | null;
  cta: string | null;
  variation_type: string | null;
  is_preview: boolean;
  created_at: string;
}

export interface CampaignWithPrompts extends Campaign {
  prompts: Prompt[];
}
```
  </action>
  <verify>npm run build succeeds, types file compiles without errors</verify>
  <done>Migration SQL documented, TypeScript types defined for Campaign and Prompt</done>
</task>

<task type="auto">
  <name>Task 2: Create campaign CRUD API endpoints</name>
  <files>src/app/api/campaigns/route.ts, src/app/api/campaigns/[id]/route.ts</files>
  <action>
1. Create src/app/api/campaigns/route.ts (list and create):

```typescript
// GET: List all campaigns (optionally filter by product_id query param)
// POST: Create new campaign (name, product_id, goal)
```

- GET returns campaigns with their prompt count
- Support optional `?product_id=uuid` query param to filter by product
- POST creates campaign with status='draft' and returns the created record
- Use createClient from '@/lib/supabase/server'
- Return proper HTTP status codes (200, 201, 400, 500)

2. Create src/app/api/campaigns/[id]/route.ts (get, update, delete):

```typescript
// GET: Get single campaign with all prompts
// PATCH: Update campaign (name, goal, status)
// DELETE: Delete campaign (cascades to prompts)
```

- GET returns full campaign with prompts array, sorted by created_at
- PATCH accepts partial updates to campaign fields
- DELETE removes campaign and all prompts (cascade)
- Validate UUID format for id parameter
- Return 404 for non-existent campaigns

Follow the pattern from /api/products/[id]/route.ts.
  </action>
  <verify>npm run build succeeds, no TypeScript errors in API routes</verify>
  <done>Campaign API endpoints created: GET /api/campaigns, POST /api/campaigns, GET/PATCH/DELETE /api/campaigns/[id]</done>
</task>

<task type="auto">
  <name>Task 3: Create prompt generation endpoint</name>
  <files>src/app/api/campaigns/[id]/prompts/route.ts</files>
  <action>
Create src/app/api/campaigns/[id]/prompts/route.ts:

```typescript
// POST: Generate prompts for campaign
// DELETE: Clear all prompts for campaign (for regeneration)
```

POST implementation:
1. Accept JSON body: { preview?: boolean, count?: number }
   - preview=true: generate 3 sample prompts (default)
   - preview=false: generate full batch (count, default 50)
2. Fetch campaign with product and brand data
3. Build context for Gemini:
   - Brand: name, colors (hex codes), fonts, tone descriptors
   - Product: name, description, hero image URL
   - Goal: awareness/lead_gen/conversion (affects messaging style)
4. Call Gemini to generate prompts (structured output)
5. Insert prompts into database with is_preview flag
6. Update campaign status to 'generating' then 'complete'
7. Return generated prompts

Gemini prompt structure:
- For awareness: focus on brand storytelling, emotional connection
- For lead_gen: focus on value proposition, curiosity hooks
- For conversion: focus on urgency, specific benefits, clear CTAs

Each prompt should include:
- prompt_text: Full image generation prompt (for Imagen 3)
- headline: Ad headline text
- description: Ad description text
- cta: Call to action text
- variation_type: Category of variation

DELETE implementation:
1. Delete all prompts for campaign (WHERE campaign_id = id)
2. Reset campaign status to 'draft'
3. Return success

Error handling:
- 400 if campaign not found or no product associated
- 500 if Gemini or database fails
  </action>
  <verify>npm run build succeeds, no TypeScript errors</verify>
  <done>POST /api/campaigns/[id]/prompts generates preview or full batch, DELETE clears for regeneration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] TypeScript types compile without errors
- [ ] API route files have correct exports (GET, POST, PATCH, DELETE)
- [ ] No ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Database types defined and importable
- Campaign CRUD API endpoints exist
- Prompt generation endpoint calls Gemini and stores results
- Ready for Prompt Generation UI (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/04-prompt-generation/04-01-SUMMARY.md`

Commit guidance:
- Task 1: `feat(04-01): add campaign database types and migration`
- Task 2: `feat(04-01): create campaign CRUD API endpoints`
- Task 3: `feat(04-01): create prompt generation endpoint`
- Metadata: `docs(04-01): complete prompt data foundation plan`
</output>
