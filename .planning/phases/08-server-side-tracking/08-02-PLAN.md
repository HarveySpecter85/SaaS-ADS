---
phase: 08-server-side-tracking
plan: 02
type: execute
depends_on: ["08-01"]
files_modified: [src/lib/google-capi.ts, src/app/api/conversions/sync/route.ts, supabase/migrations/009_capi_config.sql, src/lib/supabase/database.types.ts]
---

<objective>
Integrate with Google Ads Conversion API (CAPI) for server-side event tracking.

Purpose: Send conversion events directly to Google Ads for improved attribution in a cookieless world.
Output: Google CAPI client, sync endpoint, configuration storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-server-side-tracking/08-01-SUMMARY.md

**From 08-01 (conversion events available):**
- Conversion events table with hashed user data
- Event sync status tracking (pending, queued, sent, failed)
- Helper functions for data preparation

**Google Ads CAPI overview:**
- Upload offline conversions via Google Ads API
- Requires: Customer ID, Conversion Action ID, OAuth credentials
- Enhanced Conversions: Include hashed user identifiers
- Batch uploads recommended (up to 2000 per request)

**Implementation approach:**
- Store CAPI credentials per brand (each client has own Google Ads account)
- Create sync endpoint that processes pending events
- Batch events and send to Google Ads API
- Track sync status and handle failures
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CAPI configuration schema</name>
  <files>supabase/migrations/009_capi_config.sql, src/lib/supabase/database.types.ts</files>
  <action>
1. Create supabase/migrations/009_capi_config.sql:

```sql
-- Google Ads CAPI configuration per brand
create table capi_configs (
  id uuid primary key default gen_random_uuid(),
  brand_id uuid references brands(id) on delete cascade unique,

  -- Google Ads credentials
  customer_id text not null,           -- Google Ads Customer ID (without dashes)
  conversion_action_id text not null,  -- Conversion Action resource name

  -- OAuth tokens (encrypted in production)
  access_token text,
  refresh_token text,
  token_expires_at timestamptz,

  -- Configuration
  is_active boolean not null default true,
  batch_size integer not null default 200,
  sync_interval_minutes integer not null default 15,

  -- Metadata
  last_sync_at timestamptz,
  last_sync_status text,
  last_sync_count integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable RLS
alter table capi_configs enable row level security;

-- Policies for authenticated users
create policy "Authenticated users can CRUD capi_configs" on capi_configs
  for all using (auth.role() = 'authenticated');

-- Index for brand lookup
create index idx_capi_configs_brand on capi_configs(brand_id);
create index idx_capi_configs_active on capi_configs(is_active) where is_active = true;
```

2. Update src/lib/supabase/database.types.ts - ADD:

```typescript
// CAPI Configuration types
export interface CAPIConfig {
  id: string;
  brand_id: string;
  customer_id: string;
  conversion_action_id: string;
  access_token: string | null;
  refresh_token: string | null;
  token_expires_at: string | null;
  is_active: boolean;
  batch_size: number;
  sync_interval_minutes: number;
  last_sync_at: string | null;
  last_sync_status: string | null;
  last_sync_count: number;
  created_at: string;
  updated_at: string;
}

export interface CAPIConfigWithBrand extends CAPIConfig {
  brand: Brand;
}
```
  </action>
  <verify>npm run build succeeds, types compile</verify>
  <done>CAPI configuration table and types defined</done>
</task>

<task type="auto">
  <name>Task 2: Create Google CAPI client library</name>
  <files>src/lib/google-capi.ts</files>
  <action>
Create src/lib/google-capi.ts:

```typescript
import { ConversionEvent, CAPIConfig } from '@/lib/supabase/database.types';

// Google Ads API endpoint
const GOOGLE_ADS_API_VERSION = 'v17';
const GOOGLE_ADS_API_BASE = 'https://googleads.googleapis.com';

// Conversion upload request format
interface ConversionUpload {
  conversionAction: string;
  conversionDateTime: string;
  conversionValue?: number;
  currencyCode?: string;
  orderId?: string;
  userIdentifiers?: UserIdentifier[];
}

interface UserIdentifier {
  hashedEmail?: string;
  hashedPhoneNumber?: string;
  addressInfo?: {
    hashedFirstName?: string;
    hashedLastName?: string;
  };
}

// Sync result
export interface CAPISyncResult {
  success: boolean;
  totalEvents: number;
  successCount: number;
  failureCount: number;
  errors: string[];
}

// Build conversion action resource name
function buildConversionActionName(customerId: string, conversionActionId: string): string {
  return `customers/${customerId}/conversionActions/${conversionActionId}`;
}

// Format datetime for Google Ads (yyyy-mm-dd hh:mm:ss+|-hh:mm)
function formatGoogleDateTime(isoDate: string): string {
  const date = new Date(isoDate);
  // Format: 2024-01-15 14:30:00+00:00
  return date.toISOString().replace('T', ' ').replace('Z', '+00:00').slice(0, -5) + '+00:00';
}

// Convert our events to Google Ads format
function convertToGoogleFormat(
  event: ConversionEvent,
  conversionActionName: string
): ConversionUpload {
  const upload: ConversionUpload = {
    conversionAction: conversionActionName,
    conversionDateTime: formatGoogleDateTime(event.event_time),
  };

  // Add value if present
  if (event.event_value !== null) {
    upload.conversionValue = event.event_value;
    upload.currencyCode = event.currency;
  }

  // Add order ID if present
  if (event.transaction_id) {
    upload.orderId = event.transaction_id;
  }

  // Add user identifiers for Enhanced Conversions
  const userIdentifiers: UserIdentifier[] = [];

  if (event.user_email_hash) {
    userIdentifiers.push({ hashedEmail: event.user_email_hash });
  }

  if (event.user_phone_hash) {
    userIdentifiers.push({ hashedPhoneNumber: event.user_phone_hash });
  }

  if (event.user_first_name_hash || event.user_last_name_hash) {
    userIdentifiers.push({
      addressInfo: {
        hashedFirstName: event.user_first_name_hash || undefined,
        hashedLastName: event.user_last_name_hash || undefined,
      },
    });
  }

  if (userIdentifiers.length > 0) {
    upload.userIdentifiers = userIdentifiers;
  }

  return upload;
}

// Upload conversions to Google Ads
export async function uploadConversions(
  config: CAPIConfig,
  events: ConversionEvent[]
): Promise<CAPISyncResult> {
  const result: CAPISyncResult = {
    success: false,
    totalEvents: events.length,
    successCount: 0,
    failureCount: 0,
    errors: [],
  };

  if (events.length === 0) {
    result.success = true;
    return result;
  }

  if (!config.access_token) {
    result.errors.push('No access token configured');
    result.failureCount = events.length;
    return result;
  }

  const conversionActionName = buildConversionActionName(
    config.customer_id,
    config.conversion_action_id
  );

  // Convert events to Google format
  const conversions = events.map(event =>
    convertToGoogleFormat(event, conversionActionName)
  );

  // Build request
  const url = `${GOOGLE_ADS_API_BASE}/${GOOGLE_ADS_API_VERSION}/customers/${config.customer_id}:uploadClickConversions`;

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${config.access_token}`,
        'Content-Type': 'application/json',
        'developer-token': process.env.GOOGLE_ADS_DEVELOPER_TOKEN || '',
        'login-customer-id': config.customer_id,
      },
      body: JSON.stringify({
        conversions,
        partialFailure: true, // Continue even if some fail
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      result.errors.push(`API error: ${response.status} - ${errorText}`);
      result.failureCount = events.length;
      return result;
    }

    const data = await response.json();

    // Parse partial failure errors
    if (data.partialFailureError) {
      const failures = data.partialFailureError.details || [];
      result.failureCount = failures.length;
      result.successCount = events.length - failures.length;
      result.errors = failures.map((f: { message: string }) => f.message);
    } else {
      result.successCount = events.length;
    }

    result.success = result.successCount > 0;
    return result;
  } catch (error) {
    result.errors.push(`Network error: ${error instanceof Error ? error.message : 'Unknown'}`);
    result.failureCount = events.length;
    return result;
  }
}

// Placeholder for OAuth token refresh (implement when needed)
export async function refreshAccessToken(config: CAPIConfig): Promise<string | null> {
  // TODO: Implement OAuth refresh flow
  // For now, return existing token
  return config.access_token;
}
```

**Key points:**
- Converts internal event format to Google Ads API format
- Includes Enhanced Conversions user identifiers
- Supports partial failure (some events succeed, some fail)
- DateTime formatting per Google's requirements
  </action>
  <verify>npm run build succeeds, google-capi.ts exports correctly</verify>
  <done>Google CAPI client library ready</done>
</task>

<task type="auto">
  <name>Task 3: Create sync endpoint for batch uploads</name>
  <files>src/app/api/conversions/sync/route.ts</files>
  <action>
Create src/app/api/conversions/sync/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { uploadConversions, CAPISyncResult } from '@/lib/google-capi';
import { ConversionEvent, CAPIConfig } from '@/lib/supabase/database.types';

interface SyncResult {
  brand_id: string;
  brand_name: string;
  events_processed: number;
  success_count: number;
  failure_count: number;
  errors: string[];
}

// POST: Sync pending conversion events to Google Ads
export async function POST(request: NextRequest) {
  const supabase = await createClient();
  const { searchParams } = new URL(request.url);

  // Optional: sync only specific brand
  const brandId = searchParams.get('brand_id');

  // Get active CAPI configs
  let configQuery = supabase
    .from('capi_configs')
    .select('*, brand:brands(id, name)')
    .eq('is_active', true);

  if (brandId) {
    configQuery = configQuery.eq('brand_id', brandId);
  }

  const { data: configs, error: configError } = await configQuery;

  if (configError) {
    return NextResponse.json({ error: configError.message }, { status: 500 });
  }

  if (!configs || configs.length === 0) {
    return NextResponse.json({
      message: 'No active CAPI configurations found',
      results: [],
    });
  }

  const results: SyncResult[] = [];

  // Process each brand's pending events
  for (const config of configs) {
    const brandId = config.brand_id;
    const brandName = (config.brand as { name: string })?.name || 'Unknown';

    // Get pending events for this brand
    const { data: events, error: eventsError } = await supabase
      .from('conversion_events')
      .select('*')
      .eq('brand_id', brandId)
      .eq('sync_status', 'pending')
      .order('event_time', { ascending: true })
      .limit(config.batch_size);

    if (eventsError) {
      results.push({
        brand_id: brandId,
        brand_name: brandName,
        events_processed: 0,
        success_count: 0,
        failure_count: 0,
        errors: [eventsError.message],
      });
      continue;
    }

    if (!events || events.length === 0) {
      results.push({
        brand_id: brandId,
        brand_name: brandName,
        events_processed: 0,
        success_count: 0,
        failure_count: 0,
        errors: [],
      });
      continue;
    }

    // Mark events as queued
    const eventIds = events.map(e => e.id);
    await supabase
      .from('conversion_events')
      .update({ sync_status: 'queued', updated_at: new Date().toISOString() })
      .in('id', eventIds);

    // Upload to Google Ads
    const syncResult = await uploadConversions(config as CAPIConfig, events as ConversionEvent[]);

    // Update event statuses based on result
    if (syncResult.successCount > 0) {
      // Mark successful events
      // Note: With partial failure, we'd need individual event tracking
      // For simplicity, if any succeed, mark all as sent
      await supabase
        .from('conversion_events')
        .update({
          sync_status: 'sent',
          synced_at: new Date().toISOString(),
          sync_attempts: 1,
          updated_at: new Date().toISOString(),
        })
        .in('id', eventIds);
    }

    if (syncResult.failureCount > 0 && syncResult.successCount === 0) {
      // All failed - mark for retry
      await supabase
        .from('conversion_events')
        .update({
          sync_status: 'failed',
          sync_error: syncResult.errors.join('; '),
          sync_attempts: 1,
          updated_at: new Date().toISOString(),
        })
        .in('id', eventIds);
    }

    // Update CAPI config with sync status
    await supabase
      .from('capi_configs')
      .update({
        last_sync_at: new Date().toISOString(),
        last_sync_status: syncResult.success ? 'success' : 'partial_failure',
        last_sync_count: events.length,
        updated_at: new Date().toISOString(),
      })
      .eq('id', config.id);

    results.push({
      brand_id: brandId,
      brand_name: brandName,
      events_processed: events.length,
      success_count: syncResult.successCount,
      failure_count: syncResult.failureCount,
      errors: syncResult.errors,
    });
  }

  const totalProcessed = results.reduce((sum, r) => sum + r.events_processed, 0);
  const totalSuccess = results.reduce((sum, r) => sum + r.success_count, 0);
  const totalFailure = results.reduce((sum, r) => sum + r.failure_count, 0);

  return NextResponse.json({
    message: `Sync complete: ${totalSuccess}/${totalProcessed} events sent`,
    summary: {
      total_processed: totalProcessed,
      total_success: totalSuccess,
      total_failure: totalFailure,
    },
    results,
  });
}

// GET: Get sync status for all brands
export async function GET() {
  const supabase = await createClient();

  const { data: configs, error } = await supabase
    .from('capi_configs')
    .select('*, brand:brands(id, name)')
    .order('last_sync_at', { ascending: false, nullsFirst: false });

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  // Get pending event counts per brand
  const { data: pendingCounts } = await supabase
    .from('conversion_events')
    .select('brand_id')
    .eq('sync_status', 'pending');

  const pendingByBrand = (pendingCounts || []).reduce((acc, event) => {
    acc[event.brand_id] = (acc[event.brand_id] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const status = configs?.map(config => ({
    brand_id: config.brand_id,
    brand_name: (config.brand as { name: string })?.name || 'Unknown',
    is_active: config.is_active,
    last_sync_at: config.last_sync_at,
    last_sync_status: config.last_sync_status,
    last_sync_count: config.last_sync_count,
    pending_events: pendingByBrand[config.brand_id] || 0,
  }));

  return NextResponse.json({ status });
}
```

**Key points:**
- Processes pending events in batches per brand
- Updates sync status after each batch
- Tracks partial failures
- GET endpoint shows sync status overview
  </action>
  <verify>npm run build succeeds, sync endpoint accessible</verify>
  <done>Sync endpoint processes pending events and uploads to Google Ads</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] CAPI configs table created
- [ ] Google CAPI client library exports correctly
- [ ] POST /api/conversions/sync processes pending events
- [ ] GET /api/conversions/sync shows status
- [ ] Event status updates correctly (pending → queued → sent/failed)
- [ ] No TypeScript or ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- CAPI configuration storage ready
- Google Ads upload logic implemented
- Batch sync endpoint working
</success_criteria>

<output>
After completion, create `.planning/phases/08-server-side-tracking/08-02-SUMMARY.md`

Commit guidance:
- Task 1: `feat(08-02): create CAPI configuration schema`
- Task 2: `feat(08-02): create Google CAPI client library`
- Task 3: `feat(08-02): create sync endpoint for batch uploads`
- Metadata: `docs(08-02): complete Google CAPI integration plan`
</output>
