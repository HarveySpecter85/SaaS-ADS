---
phase: 08-server-side-tracking
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/008_conversion_events.sql, src/lib/supabase/database.types.ts, src/app/api/conversions/route.ts, src/app/api/conversions/[id]/route.ts, src/lib/conversions.ts]
---

<objective>
Create the conversion events database and API foundation.

Purpose: Store conversion events (purchases, leads, sign-ups) that will be sent to Google via CAPI.
Output: Conversion events table, TypeScript types, CRUD API, and helper functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**From ROADMAP.md - Phase 8 Goal:**
- CAPI implementation, Enhanced Conversions setup, first-party data pipeline
- Server-side tracking for privacy-first targeting

**Conversion events concept:**
- Track user actions (purchase, lead, signup, etc.)
- Store hashed user data for Enhanced Conversions
- Queue events for batch sending to Google CAPI
- Support multiple event types and custom parameters

**Prior patterns to follow:**
- Database migration pattern from Phase 6 (data sources)
- TypeScript types in database.types.ts
- REST API pattern from existing endpoints
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversion events database schema</name>
  <files>supabase/migrations/008_conversion_events.sql, src/lib/supabase/database.types.ts</files>
  <action>
1. Create supabase/migrations/008_conversion_events.sql:

```sql
-- Conversion events for server-side tracking
create table conversion_events (
  id uuid primary key default gen_random_uuid(),

  -- Event identification
  event_name text not null,  -- 'purchase', 'lead', 'signup', 'add_to_cart', 'page_view'
  event_id text unique,      -- External event ID for deduplication

  -- User data (hashed for Enhanced Conversions)
  user_email_hash text,      -- SHA256 hash of lowercase email
  user_phone_hash text,      -- SHA256 hash of E.164 phone
  user_first_name_hash text, -- SHA256 hash of lowercase first name
  user_last_name_hash text,  -- SHA256 hash of lowercase last name
  user_ip text,              -- IP address (for geo)
  user_agent text,           -- Browser user agent

  -- Event data
  event_value decimal(10,2), -- Monetary value (for purchases)
  currency text default 'USD',
  transaction_id text,       -- Order ID for purchases

  -- Custom parameters (JSON for flexibility)
  custom_params jsonb default '{}',

  -- Tracking metadata
  source text,               -- 'website', 'chat', 'api'
  campaign_id uuid references campaigns(id) on delete set null,
  brand_id uuid references brands(id) on delete set null,

  -- CAPI sync status
  sync_status text not null default 'pending' check (sync_status in (
    'pending',    -- Not yet sent
    'queued',     -- In queue for sending
    'sent',       -- Successfully sent to Google
    'failed',     -- Failed to send (will retry)
    'skipped'     -- Skipped (e.g., test event)
  )),
  sync_attempts integer default 0,
  synced_at timestamptz,
  sync_error text,

  -- Timestamps
  event_time timestamptz not null default now(),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable RLS
alter table conversion_events enable row level security;

-- Policies for authenticated users
create policy "Authenticated users can CRUD conversion_events" on conversion_events
  for all using (auth.role() = 'authenticated');

-- Indexes for common queries
create index idx_conversion_events_status on conversion_events(sync_status);
create index idx_conversion_events_event_name on conversion_events(event_name);
create index idx_conversion_events_event_time on conversion_events(event_time desc);
create index idx_conversion_events_campaign on conversion_events(campaign_id) where campaign_id is not null;
create index idx_conversion_events_brand on conversion_events(brand_id) where brand_id is not null;
```

2. Update src/lib/supabase/database.types.ts - ADD:

```typescript
// Conversion event types
export type ConversionEventName = 'purchase' | 'lead' | 'signup' | 'add_to_cart' | 'page_view' | 'custom';
export type ConversionSyncStatus = 'pending' | 'queued' | 'sent' | 'failed' | 'skipped';

export interface ConversionEvent {
  id: string;
  event_name: ConversionEventName;
  event_id: string | null;
  user_email_hash: string | null;
  user_phone_hash: string | null;
  user_first_name_hash: string | null;
  user_last_name_hash: string | null;
  user_ip: string | null;
  user_agent: string | null;
  event_value: number | null;
  currency: string;
  transaction_id: string | null;
  custom_params: Record<string, unknown>;
  source: string | null;
  campaign_id: string | null;
  brand_id: string | null;
  sync_status: ConversionSyncStatus;
  sync_attempts: number;
  synced_at: string | null;
  sync_error: string | null;
  event_time: string;
  created_at: string;
  updated_at: string;
}

export interface ConversionEventInsert {
  event_name: ConversionEventName;
  event_id?: string;
  user_email?: string;      // Will be hashed before storage
  user_phone?: string;      // Will be hashed before storage
  user_first_name?: string; // Will be hashed before storage
  user_last_name?: string;  // Will be hashed before storage
  user_ip?: string;
  user_agent?: string;
  event_value?: number;
  currency?: string;
  transaction_id?: string;
  custom_params?: Record<string, unknown>;
  source?: string;
  campaign_id?: string;
  brand_id?: string;
  event_time?: string;
}
```
  </action>
  <verify>npm run build succeeds, types compile</verify>
  <done>Conversion events table and types defined</done>
</task>

<task type="auto">
  <name>Task 2: Create conversion helpers and hashing utilities</name>
  <files>src/lib/conversions.ts</files>
  <action>
Create src/lib/conversions.ts:

```typescript
import { createHash } from 'crypto';
import { ConversionEventInsert } from '@/lib/supabase/database.types';

// Hash user data for Enhanced Conversions (SHA256, lowercase)
export function hashUserData(value: string | undefined): string | null {
  if (!value) return null;
  const normalized = value.toLowerCase().trim();
  return createHash('sha256').update(normalized).digest('hex');
}

// Normalize phone to E.164 format before hashing
export function normalizePhone(phone: string): string {
  // Remove all non-digits
  const digits = phone.replace(/\D/g, '');
  // Assume US if no country code and 10 digits
  if (digits.length === 10) {
    return '+1' + digits;
  }
  // Add + if missing
  return digits.startsWith('+') ? digits : '+' + digits;
}

// Prepare event data for database insertion
export function prepareConversionEvent(input: ConversionEventInsert): {
  event_name: string;
  event_id: string | null;
  user_email_hash: string | null;
  user_phone_hash: string | null;
  user_first_name_hash: string | null;
  user_last_name_hash: string | null;
  user_ip: string | null;
  user_agent: string | null;
  event_value: number | null;
  currency: string;
  transaction_id: string | null;
  custom_params: Record<string, unknown>;
  source: string | null;
  campaign_id: string | null;
  brand_id: string | null;
  event_time: string;
} {
  return {
    event_name: input.event_name,
    event_id: input.event_id || null,
    user_email_hash: hashUserData(input.user_email),
    user_phone_hash: input.user_phone ? hashUserData(normalizePhone(input.user_phone)) : null,
    user_first_name_hash: hashUserData(input.user_first_name),
    user_last_name_hash: hashUserData(input.user_last_name),
    user_ip: input.user_ip || null,
    user_agent: input.user_agent || null,
    event_value: input.event_value ?? null,
    currency: input.currency || 'USD',
    transaction_id: input.transaction_id || null,
    custom_params: input.custom_params || {},
    source: input.source || null,
    campaign_id: input.campaign_id || null,
    brand_id: input.brand_id || null,
    event_time: input.event_time || new Date().toISOString(),
  };
}

// Generate unique event ID for deduplication
export function generateEventId(prefix: string = 'evt'): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 8);
  return `${prefix}_${timestamp}_${random}`;
}
```

**Key points:**
- SHA256 hashing for Enhanced Conversions compliance
- Phone normalization to E.164 format
- Event ID generation for deduplication
- Prepare function handles the raw-to-hashed transformation
  </action>
  <verify>npm run build succeeds, conversions.ts exports correctly</verify>
  <done>Conversion helpers and hashing utilities ready</done>
</task>

<task type="auto">
  <name>Task 3: Create conversion events API</name>
  <files>src/app/api/conversions/route.ts, src/app/api/conversions/[id]/route.ts</files>
  <action>
1. Create src/app/api/conversions/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { prepareConversionEvent, generateEventId } from '@/lib/conversions';
import { ConversionEventInsert } from '@/lib/supabase/database.types';

// GET: List conversion events (with filters)
export async function GET(request: NextRequest) {
  const supabase = await createClient();
  const { searchParams } = new URL(request.url);

  const status = searchParams.get('status');
  const event_name = searchParams.get('event_name');
  const campaign_id = searchParams.get('campaign_id');
  const limit = parseInt(searchParams.get('limit') || '50');
  const offset = parseInt(searchParams.get('offset') || '0');

  let query = supabase
    .from('conversion_events')
    .select('*', { count: 'exact' })
    .order('event_time', { ascending: false })
    .range(offset, offset + limit - 1);

  if (status) query = query.eq('sync_status', status);
  if (event_name) query = query.eq('event_name', event_name);
  if (campaign_id) query = query.eq('campaign_id', campaign_id);

  const { data, error, count } = await query;

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json({ data, count, limit, offset });
}

// POST: Create new conversion event
export async function POST(request: NextRequest) {
  const supabase = await createClient();
  const body = await request.json() as ConversionEventInsert;

  if (!body.event_name) {
    return NextResponse.json({ error: 'event_name is required' }, { status: 400 });
  }

  // Generate event ID if not provided
  const event_id = body.event_id || generateEventId(body.event_name);

  // Prepare event with hashed user data
  const eventData = prepareConversionEvent({
    ...body,
    event_id,
  });

  const { data, error } = await supabase
    .from('conversion_events')
    .insert(eventData)
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(data, { status: 201 });
}
```

2. Create src/app/api/conversions/[id]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

// GET: Get single conversion event
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('conversion_events')
    .select('*')
    .eq('id', id)
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 404 });
  }

  return NextResponse.json(data);
}

// DELETE: Delete conversion event
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const supabase = await createClient();

  const { error } = await supabase
    .from('conversion_events')
    .delete()
    .eq('id', id);

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return new NextResponse(null, { status: 204 });
}

// PATCH: Update sync status (for retry logic)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const supabase = await createClient();
  const body = await request.json();

  // Only allow updating sync-related fields
  const allowedFields = ['sync_status', 'sync_error', 'synced_at', 'sync_attempts'];
  const updates: Record<string, unknown> = { updated_at: new Date().toISOString() };

  for (const field of allowedFields) {
    if (field in body) {
      updates[field] = body[field];
    }
  }

  const { data, error } = await supabase
    .from('conversion_events')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(data);
}
```
  </action>
  <verify>npm run build succeeds, API endpoints accessible</verify>
  <done>Conversion events CRUD API working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] Conversion events table created via migration
- [ ] TypeScript types compile without errors
- [ ] POST /api/conversions creates event with hashed user data
- [ ] GET /api/conversions lists events with filters
- [ ] Hashing utilities work correctly
- [ ] No TypeScript or ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Conversion events database foundation ready
- User data hashing implemented for Enhanced Conversions
- API endpoints follow established patterns
</success_criteria>

<output>
After completion, create `.planning/phases/08-server-side-tracking/08-01-SUMMARY.md`

Commit guidance:
- Task 1: `feat(08-01): create conversion events database schema`
- Task 2: `feat(08-01): create conversion helpers and hashing utilities`
- Task 3: `feat(08-01): create conversion events API`
- Metadata: `docs(08-01): complete conversion events foundation plan`
</output>
