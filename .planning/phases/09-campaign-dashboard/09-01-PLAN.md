---
phase: 09-campaign-dashboard
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/010_api_usage.sql, src/lib/supabase/database.types.ts, src/lib/api-usage.ts, src/app/api/usage/route.ts]
---

<objective>
Create API usage tracking foundation for monitoring Gemini API consumption.

Purpose: Track API calls to Gemini for cost monitoring and usage analytics.
Output: API usage table, types, tracking utilities, and usage API endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**From ROADMAP.md - Phase 9 Goal:**
- Dashboard showing campaigns per client, creative history, API usage metrics
- Multi-client management for agency use

**Existing patterns:**
- Migration pattern from Phase 8 (008_conversion_events.sql, 009_capi_config.sql)
- TypeScript types in database.types.ts
- API route patterns from existing endpoints

**Key files:**
@src/lib/supabase/database.types.ts
@src/lib/chat.ts (uses Gemini API)
@src/app/api/brands/[id]/extract/route.ts (uses Gemini API)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API usage database schema</name>
  <files>supabase/migrations/010_api_usage.sql, src/lib/supabase/database.types.ts</files>
  <action>
1. Create supabase/migrations/010_api_usage.sql:

```sql
-- API usage tracking for cost monitoring
create table api_usage (
  id uuid primary key default gen_random_uuid(),

  -- Request identification
  api_provider text not null default 'google_ai',  -- 'google_ai', 'openweathermap'
  api_endpoint text not null,                       -- 'chat', 'extract', 'generate'
  model text,                                        -- 'gemini-2.0-flash', etc.

  -- Usage metrics
  input_tokens integer default 0,
  output_tokens integer default 0,
  total_tokens integer generated always as (input_tokens + output_tokens) stored,

  -- Cost tracking (estimated)
  estimated_cost_usd decimal(10,6) default 0,

  -- Context
  brand_id uuid references brands(id) on delete set null,
  campaign_id uuid references campaigns(id) on delete set null,
  user_id uuid,

  -- Request metadata
  request_duration_ms integer,
  status text not null default 'success' check (status in ('success', 'error', 'timeout')),
  error_message text,

  -- Timestamps
  created_at timestamptz default now()
);

-- Enable RLS
alter table api_usage enable row level security;

-- Policy for authenticated users
create policy "Authenticated users can view api_usage" on api_usage
  for select using (auth.role() = 'authenticated');

create policy "Authenticated users can insert api_usage" on api_usage
  for insert with check (auth.role() = 'authenticated');

-- Indexes for analytics queries
create index idx_api_usage_provider on api_usage(api_provider);
create index idx_api_usage_created on api_usage(created_at desc);
create index idx_api_usage_brand on api_usage(brand_id) where brand_id is not null;
create index idx_api_usage_date on api_usage(date_trunc('day', created_at));
```

2. Update src/lib/supabase/database.types.ts - ADD at end:

```typescript
// API Usage types
export type APIProvider = 'google_ai' | 'openweathermap';
export type APIStatus = 'success' | 'error' | 'timeout';

export interface APIUsage {
  id: string;
  api_provider: APIProvider;
  api_endpoint: string;
  model: string | null;
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
  estimated_cost_usd: number;
  brand_id: string | null;
  campaign_id: string | null;
  user_id: string | null;
  request_duration_ms: number | null;
  status: APIStatus;
  error_message: string | null;
  created_at: string;
}

export interface APIUsageInsert {
  api_provider?: APIProvider;
  api_endpoint: string;
  model?: string;
  input_tokens?: number;
  output_tokens?: number;
  estimated_cost_usd?: number;
  brand_id?: string;
  campaign_id?: string;
  user_id?: string;
  request_duration_ms?: number;
  status?: APIStatus;
  error_message?: string;
}

export interface APIUsageStats {
  total_requests: number;
  total_tokens: number;
  total_cost_usd: number;
  by_provider: { provider: string; requests: number; tokens: number; cost: number }[];
  by_endpoint: { endpoint: string; requests: number; tokens: number }[];
  by_day: { date: string; requests: number; tokens: number }[];
}
```
  </action>
  <verify>npm run build succeeds, types compile</verify>
  <done>API usage table and types defined</done>
</task>

<task type="auto">
  <name>Task 2: Create API usage tracking utilities</name>
  <files>src/lib/api-usage.ts</files>
  <action>
Create src/lib/api-usage.ts:

```typescript
import { createClient } from '@/lib/supabase/server';
import { APIUsageInsert, APIProvider } from '@/lib/supabase/database.types';

// Gemini pricing (per 1M tokens) - as of Jan 2026
const PRICING: Record<string, { input: number; output: number }> = {
  'gemini-2.0-flash': { input: 0.075, output: 0.30 },
  'gemini-1.5-flash': { input: 0.075, output: 0.30 },
  'gemini-1.5-pro': { input: 1.25, output: 5.00 },
  'default': { input: 0.10, output: 0.40 },
};

// Calculate estimated cost
export function calculateCost(
  model: string,
  inputTokens: number,
  outputTokens: number
): number {
  const pricing = PRICING[model] || PRICING['default'];
  const inputCost = (inputTokens / 1_000_000) * pricing.input;
  const outputCost = (outputTokens / 1_000_000) * pricing.output;
  return inputCost + outputCost;
}

// Track API usage
export async function trackAPIUsage(usage: APIUsageInsert): Promise<void> {
  try {
    const supabase = await createClient();

    // Calculate cost if tokens provided
    let estimatedCost = usage.estimated_cost_usd || 0;
    if (usage.model && usage.input_tokens && usage.output_tokens) {
      estimatedCost = calculateCost(usage.model, usage.input_tokens, usage.output_tokens);
    }

    await supabase.from('api_usage').insert({
      ...usage,
      estimated_cost_usd: estimatedCost,
    });
  } catch (error) {
    // Log but don't throw - tracking shouldn't break main flow
    console.error('Failed to track API usage:', error);
  }
}

// Helper for timing requests
export function createTimer(): () => number {
  const start = performance.now();
  return () => Math.round(performance.now() - start);
}

// Get usage stats for dashboard
export async function getUsageStats(
  days: number = 30
): Promise<{
  total_requests: number;
  total_tokens: number;
  total_cost_usd: number;
  by_provider: { provider: string; requests: number; tokens: number; cost: number }[];
  by_endpoint: { endpoint: string; requests: number; tokens: number }[];
  by_day: { date: string; requests: number; tokens: number }[];
}> {
  const supabase = await createClient();
  const since = new Date();
  since.setDate(since.getDate() - days);

  // Get all usage in date range
  const { data: usage, error } = await supabase
    .from('api_usage')
    .select('*')
    .gte('created_at', since.toISOString())
    .order('created_at', { ascending: false });

  if (error || !usage) {
    return {
      total_requests: 0,
      total_tokens: 0,
      total_cost_usd: 0,
      by_provider: [],
      by_endpoint: [],
      by_day: [],
    };
  }

  // Aggregate stats
  const total_requests = usage.length;
  const total_tokens = usage.reduce((sum, u) => sum + (u.total_tokens || 0), 0);
  const total_cost_usd = usage.reduce((sum, u) => sum + Number(u.estimated_cost_usd || 0), 0);

  // Group by provider
  const providerMap = new Map<string, { requests: number; tokens: number; cost: number }>();
  usage.forEach(u => {
    const key = u.api_provider;
    const existing = providerMap.get(key) || { requests: 0, tokens: 0, cost: 0 };
    providerMap.set(key, {
      requests: existing.requests + 1,
      tokens: existing.tokens + (u.total_tokens || 0),
      cost: existing.cost + Number(u.estimated_cost_usd || 0),
    });
  });
  const by_provider = Array.from(providerMap.entries()).map(([provider, stats]) => ({
    provider,
    ...stats,
  }));

  // Group by endpoint
  const endpointMap = new Map<string, { requests: number; tokens: number }>();
  usage.forEach(u => {
    const key = u.api_endpoint;
    const existing = endpointMap.get(key) || { requests: 0, tokens: 0 };
    endpointMap.set(key, {
      requests: existing.requests + 1,
      tokens: existing.tokens + (u.total_tokens || 0),
    });
  });
  const by_endpoint = Array.from(endpointMap.entries()).map(([endpoint, stats]) => ({
    endpoint,
    ...stats,
  }));

  // Group by day
  const dayMap = new Map<string, { requests: number; tokens: number }>();
  usage.forEach(u => {
    const date = u.created_at.split('T')[0];
    const existing = dayMap.get(date) || { requests: 0, tokens: 0 };
    dayMap.set(date, {
      requests: existing.requests + 1,
      tokens: existing.tokens + (u.total_tokens || 0),
    });
  });
  const by_day = Array.from(dayMap.entries())
    .map(([date, stats]) => ({ date, ...stats }))
    .sort((a, b) => a.date.localeCompare(b.date));

  return {
    total_requests,
    total_tokens,
    total_cost_usd,
    by_provider,
    by_endpoint,
    by_day,
  };
}
```

**Key features:**
- Token-based cost estimation using Gemini pricing
- Non-blocking tracking (errors logged but don't break main flow)
- Aggregation functions for dashboard stats
- Timer helper for measuring request duration
  </action>
  <verify>npm run build succeeds, api-usage.ts exports correctly</verify>
  <done>API usage tracking utilities ready</done>
</task>

<task type="auto">
  <name>Task 3: Create usage API endpoint</name>
  <files>src/app/api/usage/route.ts</files>
  <action>
Create src/app/api/usage/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getUsageStats } from '@/lib/api-usage';

// GET: Get usage statistics
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const days = parseInt(searchParams.get('days') || '30');

  try {
    const stats = await getUsageStats(days);
    return NextResponse.json(stats);
  } catch (error) {
    console.error('Failed to get usage stats:', error);
    return NextResponse.json(
      { error: 'Failed to get usage stats' },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>npm run build succeeds, GET /api/usage returns stats</verify>
  <done>Usage API endpoint working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] API usage table created via migration
- [ ] TypeScript types compile without errors
- [ ] GET /api/usage returns usage statistics
- [ ] No TypeScript or ESLint errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- API usage tracking foundation ready
- Dashboard can query usage stats
</success_criteria>

<output>
After completion, create `.planning/phases/09-campaign-dashboard/09-01-SUMMARY.md`

Commit guidance:
- Task 1: `feat(09-01): create API usage database schema`
- Task 2: `feat(09-01): create API usage tracking utilities`
- Task 3: `feat(09-01): create usage API endpoint`
- Metadata: `docs(09-01): complete API usage tracking plan`
</output>
